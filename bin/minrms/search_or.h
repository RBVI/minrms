//
// Copyright (c) 2002 The Regents of the University of California.
// All rights reserved.
// 
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
//   1. Redistributions of source code must retain the above copyright
//      notice, this list of conditions, and the following disclaimer.
//   2. Redistributions in binary form must reproduce the above
//      copyright notice, this list of conditions, and the following
//      disclaimer in the documentation and/or other materials provided
//      with the distribution.
//   3. Redistributions must acknowledge that this software was
//      originally developed by the UCSF Computer Graphics Laboratory
//      under support by the NIH National Center for Research Resources,
//      grant P41-RR01081.
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER "AS IS" AND ANY
// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
// PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
// OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
// BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
// WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
// OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
// EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

#ifndef _SEARCH_OR_H
#define _SEARCH_OR_H

//This file contains the declaration for the SearchOr class.
//The "SearchOr" class is an interface
//for pairwise structural alignment algorithms 
//that use inter-molecular criteria.
//This is further limited to algorithms
//which explicitely sample a set of relative superpositions
//("orientations") between the two structures while trying
//to find the best alignments.
//
//The most important function of SearchOr is Search(), which just
//calculates the alignments.  Other functions are provided for writing these
//alignments to files, and for refinement.

#include <biopolymer.h>
#include <or_gen.h>





namespace minrms
{

class SearchOr
{
public:

  //Search()
  //This is the function that does most of the dirty-work.
  //Search() attempts to find the best alignments possible
  //between two structures,
  //when the two structures are rotated and translated (oriented)
  //in many different ways.  Alignments are generated between the
  //structures at each of these orientations and the best alignment(s)
  //is(are) retained.
  //   The "Search()" function will take care of the details of finding
  //sub-optimal alignments (if settings.num_solutions > 1, and if alternate
  //solutions are supported.)  The details of how this is done
  //depends on the particular algorithm used.  (Some implementations
  //like SearchOrNW, do not even handle alternate alignments.)
  //SearchOr is an abstract base class.
  //    The set of orientations that are sampled
  //over is specified by the "og", "start" and "stop" arguments in the
  //following way:  Search() samples all orientations in the range
  //        [og[start], og[stop])
  //(that is, beginning at og[start], and stopping just before og[stop]).
  //I do this instead of using OrientationGenerator::iterators because,
  //just in case.
  //
  virtual void Search(OrientationGenerator const& og,
                      long start,
                      long stop) = 0;

  // -----------------------------------------------------
  //     Implementation Decisions:
  //(I could have used the following syntax for Search():
  // virtual void Search(OrientationGenerator::const_iterator start,
  //                     OrientationGenerator::const_iterator stop);
  // Here's why "stop" and "start" are long integers instead of iterators:
  // Sometimes, when searching for alternate alignments, it becomes necessary
  // to make comparisons between alignments that were calculated at
  // orientations that are not in this range we are searching: [start, stop).
  // (Things get really ugly if alignments at those other
  // orientations are simultaneously being generated by another processor.)
  // In these cases, I need to allow the Search() function to have random
  // access to all of the orientations in "og", not just the ones in
  // [start,stop).  The decision to pass the entire container "og"
  // as an argument, as opposed to iterators pointing to a few orientations
  // was intended to help anyone who tries to write a
  // parallel-ized version of minrms later on.)
  // -----------------------------------------------------


  //Refine()
  //Refine() improves the alignment(s) found by Search(), by
  //using these alignments to move the two molecules
  //to a more optimal relative position.  Alignments are generated
  //at this new orientation, and the process is repeated until
  //either the alignment remains the same after two successive iterations,
  //or settings.refine_max_iters iterations have been performed.
  //    (The details of how this is done, depends on the particular
  //     algorithm used.  SearchOr is an abstract base class.)
  virtual void Refine() = 0;

  //WriteMSF()
  //WriteMSF() writes the alignment(s) calculated so far to a file
  //in MSF format.
  virtual void WriteMSF(bool  show_number_lines = true,
                        bool  compress_using_lower_case = false) const = 0;


  //WriteChimeraInfo()
  //WriteChimeraInfo() writes additional information specific to
  //Chimera, to a few files.  Unlike WriteMSF(), the files created
  //by this function are not intended for use outside Chimera.
  virtual void WriteChimeraInfo() const = 0;










  // *****************************************************************************
  // ****     Settings:
  // ****  The Settings class contains parameters that modify
  // **** the behavior of Search(), Refine(), WriteMSF(), and WriteChimeraInfo().
  // **** They are included in the parameters that will be used by all
  // **** children of the SearchOr class.  They will be set once during
  // **** instantiation of the child class, and cannot be modified.
  // *****************************************************************************

  struct Settings:public virtual PairAlignSettings
  {
    //Alternate solutions:
    //How do we keep track of alternate solutions?

    int   num_solutions;   //Determines how many alternate-solutions
                           //(2nd-best, 3rd-best, 4th-best) will be
                           // reported in addition to every "best"
                           // solution.
                           // Example: if num_solutions == 3, then
                           // best, 2nd-best and 3rd best solutions
                           // will be returned to the user.

    //  The following type species several possible ways of determining.
    //whether two solutions are sufficiently dissimilar to be
    //considered "alternate solutions".
    //For example, 1st-best and 2nd best solutions,
    //must be reasonably dissimilar from eachother,
    //since there's no point in reporting them separately,
    //if they're almost identical.
    //
    //(Note: The ability to generate alternate solutions may not be
    //       supported by all child classes of SearchOr, specifically
    //       SearchOrNW.  However alternate solutions presently supported
    //       by SearchOrDyn3d.)
    enum AltMethodType {ALT_METHOD_3D,   //If the relative orientation between
                                         //the two structures after optimal 
                                         //superposition according to the
                                         //residues matched in the two
                                         //alignments is sufficiently different
                                         //then the two alignments can be
                                         //considered "alternate" solutions.
                                         //
                                         //(This is the same metric used
                                         // when using the "-3d" option
                                         // in the msf_compare program.
                                         // See ../msf_compare/msf_compare.cc.)

                        ALT_METHOD_3D_ORIG, //If the two orientations that
                                            //spawned two different alignments
                                            //is sufficiently different,
                                            //then the two alignments can
                                            //be alternates of eachother.
                                            //  This is different than the
                                            //ALT_METHOD_ALL_3D method because
                                            //the orientations being compared
                                            //here are the orientations that
                                         //were used to generate the alignments
                                            //in the first place.  They are
                                            //not orientations that can
                                            //be inferred or generated from
                                            //the alignments themselves.

                        ALT_METHOD_PAIRS}; //If the number if identical pairs
                                           //of matched residues common to both
                                           //alignments is low enough,
                                           //the two alignments can be
                                           //considered "alternate" solutions

    AltMethodType alt_method;

    Real alt_min_3d_difference; //This parameter only makes sense
                                //if alternates have been requested,
                                //and if:
                                //alt_method == ALT_METHOD_3D, or
                                //alt_method == ALT_METHOD_3D_ORIG
                                //It specifies the minimum RMS distance between
                                //the position of the second molecule
                                //at the two orientations corresponding
                                //to two different solutions.
                                //If two solutions have orientations that
                                //differ by at least alt_min_3d_difference,
                                //then both solutions are considered
                                //suffeciently different to be reported.

    int  alt_max_pairs_common;  //This parameter only makes sense
                                //if alternates have been requested,
                                //and if:
                                //alt_method == ALT_METHOD_PAIRS, or
                                //alt_method == ALT_METHOD_PAIRS_FAST.
                                //It specifies the maximum number of pairs of
                                //matched residues the two alignments can
                                //have in common.  If two solutions have
                                //more than this number of identical pairs
                                //of residues, then they are too similar
                                //to be reported as "alternate" solutions.

    Real alt_rmsd_tolerance;// This parameter only make sense if alternate
                        // solutions have been requested.  (...That is, if:
                        // SearchOr::Settings::num_solutions > 1)  If so, then
                        // only alternate alignments whose RMSDs does not
                        // exceed alt_rmsd_tolerance * RMSD_of_best_alignment,
                        // will be reported.  To dissable this feature,
                        // set to ALTERNATES_NOT_LIMITED_BY_RMSD.

    static const Real ALTERNATES_NOT_LIMITED_BY_RMSD;


    // Refinement:
    // Iterative-refinement is the process of using only the residues
    // paired by the previously calculated alignment to find a better
    // orientation.  New alignments are then made at this new orientation
    // and the process is repeated for a maximum number of iterations
    // specified by this argument.
    //The following are possible values for the "refine_mode" setting
    //They indicate whether to perform iterative refinement on the solution
    //after the initial orientation search, and if so, _which_ solutions.
    enum RefineMethodType {NO_REFINE,   //No iterative refinement.
                           REFINE_BEST, //run iterative refinement only
                                         //on the best alignments with the
                                         //minimum RMSD after the initial
                                         //orientation search.
                           REFINE_ALL   //run iterative refinement on
                          };             //alternate (2nd-best, 3rd-best)
                                         //solutions as well as the primary
                                         //ones after the initial
                                         //orientation search.
    RefineMethodType refine_method;

    // Iterative-refinement is the process of using only the residues
    // paired by the previously calculated alignment to find a better
    // orientation.  New alignments are then made at this new orientation
    // and the process is repeated for a maximum number of iterations
    // specified by this argument.
    //  Arguments:
    //   If the refine_max_iters argument is set
    // to ITERATE_UNTIL_CONVERGENCE, then there is no iteration limit.
    // If the argument is set to zero (the default), then there will be no
    // refinement of the initial orientation.)

    long     refine_max_iters;
    static const int ITERATE_UNTIL_CONVERGENCE = -1;

    //This next variable is sort of specific to 
    //algorithms that minimize RMSD
    bool  refine_while_searching; //For SearchOrNW, and SearchOrDyn3d,
                                  //setting this variable = true
                                  //enables more accurate RMSD
                                  //calculation of an alignment
                                  //by optimizing the orientation
                                  //between the structures before
                                  //calculating that alignment's
                                  //RMSD.  (For these algorithms,
                                  //the extra computation 
                                  //required has almost no perceptible
                                  //impact on the running time.)


#ifdef COMPILER_BUG2
    Settings();

    //copy constructor:
    //(The alpha compiler produces buggy
    // binaries unless I define one explicitly)
    Settings(Settings const &s);
    //SearchOr::Settings::Settings(Settings const& s):
    //PairAlignSettings(s) {}
#endif //#ifdef COMPILER_BUG2

  }; //SearchOr::Settings



protected:
  Biopolymer *aMol_c;  //A copy of the structures in settings.aMol_f.
                       //This coly is used to perform the calculations,
                       //and it is allocated only once.
                       //Coordinates can be modified.
}; //class SearchOr

} //namespace minrms

#endif //#ifndef _SEARCH_OR_H
